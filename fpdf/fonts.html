<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>fpdf.fonts API documentation</title>
<meta name="description" content="Font-related classes &amp; constants.
Includes the definition of the character widths of all PDF standard fonts â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>fpdf.fonts</code></h1>
</header>
<section id="section-intro">
<p>Font-related classes &amp; constants.
Includes the definition of the character widths of all PDF standard fonts.</p>
<p>The contents of this module are internal to fpdf2, and not part of the public API.
They may change at any time without prior warning or any deprecation period,
in non-backward-compatible ways.</p>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="fpdf.fonts.CoreFont"><code class="flex name class">
<span>class <span class="ident">CoreFont</span></span>
<span>(</span><span>fpdf, fontkey, style)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L188-L211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CoreFont:
    # RAM usage optimization:
    __slots__ = (&#34;i&#34;, &#34;type&#34;, &#34;name&#34;, &#34;up&#34;, &#34;ut&#34;, &#34;cw&#34;, &#34;fontkey&#34;, &#34;emphasis&#34;)

    def __init__(self, fpdf, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;core&#34;
        self.name = CORE_FONTS[fontkey]
        self.up = -100
        self.ut = 50
        self.cw = CORE_FONTS_CHARWIDTHS[fontkey]
        self.fontkey = fontkey
        self.emphasis = TextEmphasis.coerce(style)

    def get_text_width(self, text, font_size_pt, _):
        return (len(text), sum(self.cw[c] for c in text) * font_size_pt * 0.001)

    # Disabling this check - method kept as is to have same method/signature on CoreConf and TTFFont:
    # pylint: disable=no-self-use
    def encode_text(self, text):
        return f&#34;({escape_parens(text)}) Tj&#34;

    def __repr__(self):
        return f&#34;CoreFont(i={self.i}, fontkey={self.fontkey})&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.CoreFont.cw"><code class="name">var <span class="ident">cw</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.emphasis"><code class="name">var <span class="ident">emphasis</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.fontkey"><code class="name">var <span class="ident">fontkey</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.i"><code class="name">var <span class="ident">i</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.ut"><code class="name">var <span class="ident">ut</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.CoreFont.encode_text"><code class="name flex">
<span>def <span class="ident">encode_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.CoreFont.get_text_width"><code class="name flex">
<span>def <span class="ident">get_text_width</span></span>(<span>self, text, font_size_pt, _)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.FontFace"><code class="flex name class">
<span>class <span class="ident">FontFace</span></span>
<span>(</span><span>family=None, emphasis=None, size_pt=None, color=None, fill_color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Represent basic font styling properties.
This is a subset of <code><a title="fpdf.graphics_state.GraphicsStateMixin" href="graphics_state.html#fpdf.graphics_state.GraphicsStateMixin">GraphicsStateMixin</a></code> properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L41-L110" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass
class FontFace:
    &#34;&#34;&#34;
    Represent basic font styling properties.
    This is a subset of `fpdf.graphics_state.GraphicsStateMixin` properties.
    &#34;&#34;&#34;

    __slots__ = (  # RAM usage optimization
        &#34;family&#34;,
        &#34;emphasis&#34;,
        &#34;size_pt&#34;,
        &#34;color&#34;,
        &#34;fill_color&#34;,
    )
    family: Optional[str]
    emphasis: Optional[TextEmphasis]  # None means &#34;no override&#34;
    #                                   Whereas &#34;&#34; means &#34;no emphasis&#34;
    #                                   This can be a combination: B | U
    size_pt: Optional[int]
    # Colors are single number grey scales or (red, green, blue) tuples:
    color: Optional[Union[DeviceGray, DeviceRGB]]
    fill_color: Optional[Union[DeviceGray, DeviceRGB]]

    def __init__(
        self, family=None, emphasis=None, size_pt=None, color=None, fill_color=None
    ):
        self.family = family
        self.emphasis = None if emphasis is None else TextEmphasis.coerce(emphasis)
        self.size_pt = size_pt
        self.color = None if color is None else convert_to_device_color(color)
        self.fill_color = (
            None if fill_color is None else convert_to_device_color(fill_color)
        )

    replace = replace

    @staticmethod
    def _override(current_value, override_value):
        &#34;&#34;&#34;Override the current value if an override value is provided&#34;&#34;&#34;
        return current_value if override_value is None else override_value

    @staticmethod
    def combine(default_style, override_style):
        &#34;&#34;&#34;
        Create a combined FontFace with all the supplied features of the two styles. When both
        the default and override styles provide a feature, prefer the override style.
        Override specified FontFace style features
        Override this FontFace&#39;s values with the values of `other`.
        Values of `other` that are None in this FontFace will be kept unchanged.
        &#34;&#34;&#34;
        if override_style is None:
            return default_style
        if default_style is None:
            return override_style
        if not isinstance(override_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(override_style)}&#34;)
        if not isinstance(default_style, FontFace):
            raise TypeError(f&#34;Cannot combine FontFace with {type(default_style)}&#34;)
        return FontFace(
            family=FontFace._override(default_style.family, override_style.family),
            emphasis=FontFace._override(
                default_style.emphasis,
                override_style.emphasis,
            ),
            size_pt=FontFace._override(default_style.size_pt, override_style.size_pt),
            color=FontFace._override(default_style.color, override_style.color),
            fill_color=FontFace._override(
                default_style.fill_color, override_style.fill_color
            ),
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="fpdf.fonts.FontFace.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>default_style, override_style)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a combined FontFace with all the supplied features of the two styles. When both
the default and override styles provide a feature, prefer the override style.
Override specified FontFace style features
Override this FontFace's values with the values of <code>other</code>.
Values of <code>other</code> that are None in this FontFace will be kept unchanged.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.FontFace.color"><code class="name">var <span class="ident">color</span> :Â Union[<a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>,Â <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a>,Â ForwardRef(None)]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.emphasis"><code class="name">var <span class="ident">emphasis</span> :Â Optional[<a title="fpdf.enums.TextEmphasis" href="enums.html#fpdf.enums.TextEmphasis">TextEmphasis</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.family"><code class="name">var <span class="ident">family</span> :Â Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.fill_color"><code class="name">var <span class="ident">fill_color</span> :Â Union[<a title="fpdf.drawing.DeviceGray" href="drawing.html#fpdf.drawing.DeviceGray">DeviceGray</a>,Â <a title="fpdf.drawing.DeviceRGB" href="drawing.html#fpdf.drawing.DeviceRGB">DeviceRGB</a>,Â ForwardRef(None)]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.FontFace.size_pt"><code class="name">var <span class="ident">size_pt</span> :Â Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.FontFace.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>obj, /, **changes)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new object replacing specified fields with new values.</p>
<p>This is especially useful for frozen classes.
Example usage::</p>
<p>@dataclass(frozen=True)
class C:
x: int
y: int</p>
<p>c = C(1, 2)
c1 = replace(c, x=3)
assert c1.x == 3 and c1.y == 2</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.Glyph"><code class="flex name class">
<span>class <span class="ident">Glyph</span></span>
<span>(</span><span>glyph_id:Â int, unicode:Â Tuple, glyph_name:Â str, glyph_width:Â int)</span>
</code></dt>
<dd>
<div class="desc"><p>This represents one glyph on the font
Unicode is a tuple because ligatures or character substitution
can map a sequence of unicode characters to a single glyph</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L481-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@dataclass(order=True)
class Glyph:
    &#34;&#34;&#34;
    This represents one glyph on the font
    Unicode is a tuple because ligatures or character substitution
    can map a sequence of unicode characters to a single glyph
    &#34;&#34;&#34;

    # RAM usage optimization:
    __slots__ = (&#34;glyph_id&#34;, &#34;unicode&#34;, &#34;glyph_name&#34;, &#34;glyph_width&#34;)
    glyph_id: int
    unicode: Tuple
    glyph_name: str
    glyph_width: int

    def __hash__(self):
        return self.glyph_id</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.Glyph.glyph_id"><code class="name">var <span class="ident">glyph_id</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.glyph_name"><code class="name">var <span class="ident">glyph_name</span> :Â str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.glyph_width"><code class="name">var <span class="ident">glyph_width</span> :Â int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.Glyph.unicode"><code class="name">var <span class="ident">unicode</span> :Â Tuple</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.HarfBuzzFont"><code class="flex name class">
<span>class <span class="ident">HarfBuzzFont</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>uharfbuzz.Font than can be deepcopied</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L24-L29" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class HarfBuzzFont(hb.Font):
    &#34;uharfbuzz.Font than can be deepcopied&#34;

    # cf. issue #1075, avoids: TypeError: no default __reduce__ due to non-trivial __cinit__
    def __deepcopy__(self, _memo):
        return self</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>uharfbuzz._harfbuzz.Font</li>
</ul>
</dd>
<dt id="fpdf.fonts.PDFFontDescriptor"><code class="flex name class">
<span>class <span class="ident">PDFFontDescriptor</span></span>
<span>(</span><span>ascent, descent, cap_height, flags, font_b_box, italic_angle, stem_v, missing_width)</span>
</code></dt>
<dd>
<div class="desc"><p>Main features of this class:
* delay ID assignement
* implement serializing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L456-L478" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class PDFFontDescriptor(PDFObject):
    def __init__(
        self,
        ascent,
        descent,
        cap_height,
        flags,
        font_b_box,
        italic_angle,
        stem_v,
        missing_width,
    ):
        super().__init__()
        self.type = Name(&#34;FontDescriptor&#34;)
        self.ascent = ascent
        self.descent = descent
        self.cap_height = cap_height
        self.flags = flags
        self.font_b_box = font_b_box
        self.italic_angle = italic_angle
        self.stem_v = stem_v
        self.missing_width = missing_width
        self.font_name = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fpdf.syntax.PDFObject" href="syntax.html#fpdf.syntax.PDFObject">PDFObject</a></b></code>:
<ul class="hlist">
<li><code><a title="fpdf.syntax.PDFObject.content_stream" href="syntax.html#fpdf.syntax.PDFObject.content_stream">content_stream</a></code></li>
<li><code><a title="fpdf.syntax.PDFObject.serialize" href="syntax.html#fpdf.syntax.PDFObject.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="fpdf.fonts.SubsetMap"><code class="flex name class">
<span>class <span class="ident">SubsetMap</span></span>
<span>(</span><span>font:Â <a title="fpdf.fonts.TTFFont" href="#fpdf.fonts.TTFFont">TTFFont</a>, identities:Â List[int])</span>
</code></dt>
<dd>
<div class="desc"><p>Holds a mapping of used characters and their position in the font's subset</p>
<p>Characters that must be mapped on their actual unicode must be part of the
<code>identities</code> list during object instanciation. These non-negative values should
only appear once in the list. <code>pick()</code> can be used to get the characters
corresponding position in the subset. If it's not yet part of the object, a new
position is acquired automatically. This implementation always tries to return
the lowest possible representation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L500-L582" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SubsetMap:
    &#34;&#34;&#34;
    Holds a mapping of used characters and their position in the font&#39;s subset

    Characters that must be mapped on their actual unicode must be part of the
    `identities` list during object instanciation. These non-negative values should
    only appear once in the list. `pick()` can be used to get the characters
    corresponding position in the subset. If it&#39;s not yet part of the object, a new
    position is acquired automatically. This implementation always tries to return
    the lowest possible representation.
    &#34;&#34;&#34;

    def __init__(self, font: TTFFont, identities: List[int]):
        super().__init__()
        self.font = font
        self._next = 0

        # sort list to ease deletion once _next
        # becomes higher than first reservation
        self._reserved = sorted(identities)

        # Maps Glyph instances to character IDs (integers):
        self._char_id_per_glyph = {}
        for x in self._reserved:
            glyph = self.get_glyph(unicode=x)
            if glyph:
                self._char_id_per_glyph[glyph] = int(x)

    def __repr__(self):
        return (
            f&#34;SubsetMap(font={self.font}, _next={self._next},&#34;
            f&#34; _reserved={self._reserved}, _char_id_per_glyph={self._char_id_per_glyph})&#34;
        )

    def __len__(self):
        return len(self._char_id_per_glyph)

    def items(self):
        for glyph, char_id in self._char_id_per_glyph.items():
            yield glyph, char_id

    # pylint: disable=method-cache-max-size-none
    @lru_cache(maxsize=None)
    def pick(self, unicode: int):
        glyph = self.get_glyph(unicode=unicode)
        if glyph is None and unicode not in self.font.missing_glyphs:
            self.font.missing_glyphs.append(unicode)
        return self.pick_glyph(glyph)

    def pick_glyph(self, glyph):
        char_id = self._char_id_per_glyph.get(glyph)
        if glyph and char_id is None:
            while self._next in self._reserved:
                self._next += 1
                if self._next &gt; self._reserved[0]:
                    del self._reserved[0]
            char_id = self._next
            self._char_id_per_glyph[glyph] = char_id
            self._next += 1
        return char_id

    # pylint: disable=method-cache-max-size-none
    @lru_cache(maxsize=None)
    def get_glyph(
        self, glyph=None, unicode=None, glyph_name=None, glyph_width=None
    ) -&gt; Glyph:
        if glyph:
            return Glyph(glyph, tuple(unicode), glyph_name, glyph_width)
        glyph_id = self.font.glyph_ids.get(unicode)
        if isinstance(unicode, int) and glyph_id is not None:
            return Glyph(
                glyph_id,
                (unicode,),
                self.font.cmap[unicode],
                self.font.cw[unicode],
            )
        if unicode == 0x00:
            glyph_id = next(iter(self.font.cmap))
            return Glyph(glyph_id, (0x00,), &#34;.notdef&#34;, 0)
        return None

    def get_all_glyph_names(self):
        return [glyph.glyph_name for glyph in self._char_id_per_glyph]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.SubsetMap.get_all_glyph_names"><code class="name flex">
<span>def <span class="ident">get_all_glyph_names</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.get_glyph"><code class="name flex">
<span>def <span class="ident">get_glyph</span></span>(<span>self, glyph=None, unicode=None, glyph_name=None, glyph_width=None) â€‘>Â <a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.pick"><code class="name flex">
<span>def <span class="ident">pick</span></span>(<span>self, unicode:Â int)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.SubsetMap.pick_glyph"><code class="name flex">
<span>def <span class="ident">pick_glyph</span></span>(<span>self, glyph)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.TTFFont"><code class="flex name class">
<span>class <span class="ident">TTFFont</span></span>
<span>(</span><span>fpdf, font_file_path, fontkey, style)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L214-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TTFFont:
    __slots__ = (  # RAM usage optimization
        &#34;i&#34;,
        &#34;type&#34;,
        &#34;name&#34;,
        &#34;desc&#34;,
        &#34;glyph_ids&#34;,
        &#34;hbfont&#34;,
        &#34;up&#34;,
        &#34;ut&#34;,
        &#34;cw&#34;,
        &#34;ttffile&#34;,
        &#34;fontkey&#34;,
        &#34;emphasis&#34;,
        &#34;scale&#34;,
        &#34;subset&#34;,
        &#34;cmap&#34;,
        &#34;ttfont&#34;,
        &#34;missing_glyphs&#34;,
    )

    def __init__(self, fpdf, font_file_path, fontkey, style):
        self.i = len(fpdf.fonts) + 1
        self.type = &#34;TTF&#34;
        self.ttffile = font_file_path
        self.fontkey = fontkey

        # recalcTimestamp=False means that it doesn&#39;t modify the &#34;modified&#34; timestamp in head table
        # if we leave recalcTimestamp=True the tests will break every time
        self.ttfont = ttLib.TTFont(
            self.ttffile, recalcTimestamp=False, fontNumber=0, lazy=True
        )

        self.scale = 1000 / self.ttfont[&#34;head&#34;].unitsPerEm
        default_width = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[&#34;.notdef&#34;][0])

        try:
            cap_height = self.ttfont[&#34;OS/2&#34;].sCapHeight
        except AttributeError:
            cap_height = self.ttfont[&#34;hhea&#34;].ascent

        # entry for the PDF font descriptor specifying various characteristics of the font
        flags = FontDescriptorFlags.SYMBOLIC
        if self.ttfont[&#34;post&#34;].isFixedPitch:
            flags |= FontDescriptorFlags.FIXED_PITCH
        if self.ttfont[&#34;post&#34;].italicAngle != 0:
            flags |= FontDescriptorFlags.ITALIC
        if self.ttfont[&#34;OS/2&#34;].usWeightClass &gt;= 600:
            flags |= FontDescriptorFlags.FORCE_BOLD

        self.desc = PDFFontDescriptor(
            ascent=round(self.ttfont[&#34;hhea&#34;].ascent * self.scale),
            descent=round(self.ttfont[&#34;hhea&#34;].descent * self.scale),
            cap_height=round(cap_height * self.scale),
            flags=flags,
            font_b_box=(
                f&#34;[{self.ttfont[&#39;head&#39;].xMin * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMin * self.scale:.0f}&#34;
                f&#34; {self.ttfont[&#39;head&#39;].xMax * self.scale:.0f} {self.ttfont[&#39;head&#39;].yMax * self.scale:.0f}]&#34;
            ),
            italic_angle=int(self.ttfont[&#34;post&#34;].italicAngle),
            stem_v=round(50 + int(pow((self.ttfont[&#34;OS/2&#34;].usWeightClass / 65), 2))),
            missing_width=default_width,
        )

        # a map unicode_char -&gt; char_width
        self.cw = defaultdict(lambda: default_width)

        # fonttools cmap = unicode char to glyph name
        # saving only the keys we have a tuple with
        # the unicode characters available on the font
        self.cmap = self.ttfont.getBestCmap()

        # saving a list of glyph ids to char to allow
        # subset by unicode (regular) and by glyph
        # (shaped with harfbuz)
        self.glyph_ids = {}

        for char in self.cmap:
            # take glyph associated to char
            glyph = self.cmap[char]

            # take width associated to glyph
            w = self.ttfont[&#34;hmtx&#34;].metrics[glyph][0]

            # probably this check could be deleted
            if w == 65535:
                w = 0

            self.cw[char] = round(self.scale * w + 0.001)  # ROUND_HALF_UP

            self.glyph_ids[char] = self.ttfont.getGlyphID(glyph)

        self.missing_glyphs = []

        # include numbers in the subset! (if alias present)
        # ensure that alias is mapped 1-by-1 additionally (must be replaceable)
        sbarr = &#34;\x00 \r\n&#34;
        if fpdf.str_alias_nb_pages:
            sbarr += &#34;0123456789&#34;
            sbarr += fpdf.str_alias_nb_pages

        self.name = re.sub(&#34;[ ()]&#34;, &#34;&#34;, self.ttfont[&#34;name&#34;].getBestFullName())
        self.up = round(self.ttfont[&#34;post&#34;].underlinePosition * self.scale)
        self.ut = round(self.ttfont[&#34;post&#34;].underlineThickness * self.scale)
        self.emphasis = TextEmphasis.coerce(style)
        self.subset = SubsetMap(self, [ord(char) for char in sbarr])

    def __repr__(self):
        return f&#34;TTFFont(i={self.i}, fontkey={self.fontkey})&#34;

    def close(self):
        self.ttfont.close()
        self.hbfont = None

    def get_text_width(self, text, font_size_pt, text_shaping_parms):
        if text_shaping_parms:
            return self.shaped_text_width(text, font_size_pt, text_shaping_parms)
        return (len(text), sum(self.cw[ord(c)] for c in text) * font_size_pt * 0.001)

    def shaped_text_width(self, text, font_size_pt, text_shaping_parms):
        &#34;&#34;&#34;
        When texts are shaped, the length of a string is not always the sum of all individual character widths
        This method will invoke harfbuzz to perform the text shaping and return the sum of &#34;x_advance&#34;
        and &#34;x_offset&#34; for each glyph. This method works for &#34;left to right&#34; or &#34;right to left&#34; texts.
        &#34;&#34;&#34;
        _, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_parms
        )

        # If there is nothing to render (harfbuzz returns None), we return 0 text width
        if glyph_positions is None:
            return (0, 0)

        text_width = 0
        for pos in glyph_positions:
            text_width += (
                round(self.scale * pos.x_advance + 0.001) * font_size_pt * 0.001
            )
        return (len(glyph_positions), text_width)

    # Disabling this check - looks like cython confuses pylint:
    # pylint: disable=no-member
    def perform_harfbuzz_shaping(self, text, font_size_pt, text_shaping_parms):
        &#34;&#34;&#34;
        This method invokes Harfbuzz to perform text shaping of the input string
        &#34;&#34;&#34;
        if not hasattr(self, &#34;hbfont&#34;):
            self.hbfont = HarfBuzzFont(hb.Face(hb.Blob.from_file_path(self.ttffile)))
        self.hbfont.ptem = font_size_pt
        buf = hb.Buffer()
        buf.cluster_level = 1
        buf.add_str(&#34;&#34;.join(text))
        buf.guess_segment_properties()
        features = text_shaping_parms[&#34;features&#34;]
        if text_shaping_parms[&#34;fragment_direction&#34;]:
            buf.direction = text_shaping_parms[&#34;fragment_direction&#34;].value
        if text_shaping_parms[&#34;script&#34;]:
            buf.script = text_shaping_parms[&#34;script&#34;]
        if text_shaping_parms[&#34;language&#34;]:
            buf.language = text_shaping_parms[&#34;language&#34;]
        hb.shape(self.hbfont, buf, features)
        return buf.glyph_infos, buf.glyph_positions

    def encode_text(self, text):
        txt_mapped = &#34;&#34;
        for char in text:
            uni = ord(char)
            # Instead of adding the actual character to the stream its code is
            # mapped to a position in the font&#39;s subset
            txt_mapped += chr(self.subset.pick(uni))
        return f&#39;({escape_parens(txt_mapped.encode(&#34;utf-16-be&#34;).decode(&#34;latin-1&#34;))}) Tj&#39;

    def shape_text(self, text, font_size_pt, text_shaping_parms):
        &#34;&#34;&#34;
        This method will invoke harfbuzz for text shaping, include the mapping code
        of the glyphs on the subset and map input characters to the cluster codes
        &#34;&#34;&#34;
        if len(text) == 0:
            return []
        glyph_infos, glyph_positions = self.perform_harfbuzz_shaping(
            text, font_size_pt, text_shaping_parms
        )
        text_info = []

        # Find cluster gaps
        # Ex: text = &#34;ABCD&#34;
        # glyph infos has cluster: 0, 2, 3 - it means A and B are together on the first glyph
        # (ligature or substitution) - the glyph should have both unicodes and it should be translated
        # properly on the CID to GID mapping
        #
        def get_cluster_from_text_index(cluster_list, index):
            pos = bisect_left(cluster_list, index)
            if pos == 0:
                return cluster_list[0]
            if pos == len(cluster_list) or cluster_list[pos] != index:
                return cluster_list[pos - 1]
            return cluster_list[pos]

        cluster_list = list(sorted(int(gi.cluster) for gi in glyph_infos))
        cluster_mapping = {}
        for i in range(len(text)):
            cl = get_cluster_from_text_index(cluster_list, i)
            if cl in cluster_mapping:
                cluster_mapping[cl].append(i)
            else:
                cluster_mapping[cl] = [i]

        for cluster_seq, gi in enumerate(glyph_infos):
            unicode = []
            if gi.cluster in cluster_mapping:
                unicode = [ord(text[i]) for i in cluster_mapping[gi.cluster]]
                cluster_mapping.pop(gi.cluster)

            gname = self.ttfont.getGlyphName(gi.codepoint)
            gwidth = round(self.scale * self.ttfont[&#34;hmtx&#34;].metrics[gname][0])
            glyph = self.subset.get_glyph(
                glyph=gi.codepoint,
                unicode=tuple(unicode),
                glyph_name=gname,
                glyph_width=gwidth,
            )
            force_positioning = False
            if (
                gwidth != glyph_positions[cluster_seq].x_advance
                or glyph_positions[cluster_seq].x_offset != 0
                or glyph_positions[cluster_seq].y_offset != 0
                or glyph_positions[cluster_seq].y_advance != 0
            ):
                force_positioning = True
            text_info.append(
                {
                    &#34;mapped_char&#34;: self.subset.pick_glyph(glyph),
                    &#34;x_advance&#34;: glyph_positions[cluster_seq].x_advance,
                    &#34;y_advance&#34;: glyph_positions[cluster_seq].y_advance,
                    &#34;x_offset&#34;: glyph_positions[cluster_seq].x_offset,
                    &#34;y_offset&#34;: glyph_positions[cluster_seq].y_offset,
                    &#34;force_positioning&#34;: force_positioning,
                }
            )
        return text_info</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="fpdf.fonts.TTFFont.cmap"><code class="name">var <span class="ident">cmap</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.cw"><code class="name">var <span class="ident">cw</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.desc"><code class="name">var <span class="ident">desc</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.emphasis"><code class="name">var <span class="ident">emphasis</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.fontkey"><code class="name">var <span class="ident">fontkey</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.glyph_ids"><code class="name">var <span class="ident">glyph_ids</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.hbfont"><code class="name">var <span class="ident">hbfont</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.i"><code class="name">var <span class="ident">i</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.missing_glyphs"><code class="name">var <span class="ident">missing_glyphs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.scale"><code class="name">var <span class="ident">scale</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.subset"><code class="name">var <span class="ident">subset</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ttffile"><code class="name">var <span class="ident">ttffile</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ttfont"><code class="name">var <span class="ident">ttfont</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.up"><code class="name">var <span class="ident">up</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.ut"><code class="name">var <span class="ident">ut</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="fpdf.fonts.TTFFont.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.encode_text"><code class="name flex">
<span>def <span class="ident">encode_text</span></span>(<span>self, text)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.get_text_width"><code class="name flex">
<span>def <span class="ident">get_text_width</span></span>(<span>self, text, font_size_pt, text_shaping_parms)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="fpdf.fonts.TTFFont.perform_harfbuzz_shaping"><code class="name flex">
<span>def <span class="ident">perform_harfbuzz_shaping</span></span>(<span>self, text, font_size_pt, text_shaping_parms)</span>
</code></dt>
<dd>
<div class="desc"><p>This method invokes Harfbuzz to perform text shaping of the input string</p></div>
</dd>
<dt id="fpdf.fonts.TTFFont.shape_text"><code class="name flex">
<span>def <span class="ident">shape_text</span></span>(<span>self, text, font_size_pt, text_shaping_parms)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will invoke harfbuzz for text shaping, include the mapping code
of the glyphs on the subset and map input characters to the cluster codes</p></div>
</dd>
<dt id="fpdf.fonts.TTFFont.shaped_text_width"><code class="name flex">
<span>def <span class="ident">shaped_text_width</span></span>(<span>self, text, font_size_pt, text_shaping_parms)</span>
</code></dt>
<dd>
<div class="desc"><p>When texts are shaped, the length of a string is not always the sum of all individual character widths
This method will invoke harfbuzz to perform the text shaping and return the sum of "x_advance"
and "x_offset" for each glyph. This method works for "left to right" or "right to left" texts.</p></div>
</dd>
</dl>
</dd>
<dt id="fpdf.fonts.TextStyle"><code class="flex name class">
<span>class <span class="ident">TextStyle</span></span>
<span>(</span><span>font_family:Â Optional[str]Â =Â None, font_style:Â Optional[str]Â =Â None, font_size_pt:Â Optional[int]Â =Â None, color:Â Union[int,Â tuple]Â =Â None, fill_color:Â Union[int,Â tuple]Â =Â None, underline:Â boolÂ =Â False, t_margin:Â Optional[int]Â =Â None, l_margin:Â Optional[int]Â =Â None, b_margin:Â Optional[int]Â =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Subclass of <code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code> that allows to specify vertical &amp; horizontal spacing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/py-pdf/fpdf2/blob/d75ae4bfacda20e577cd9ffb1eacab2ebb68c18c/fpdf/fonts.py#L113-L169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TextStyle(FontFace):
    &#34;&#34;&#34;
    Subclass of `FontFace` that allows to specify vertical &amp; horizontal spacing
    &#34;&#34;&#34;

    def __init__(
        self,
        font_family: Optional[str] = None,  # None means &#34;no override&#34;
        #                                     Whereas &#34;&#34; means &#34;no emphasis&#34;
        font_style: Optional[str] = None,
        font_size_pt: Optional[int] = None,
        color: Union[int, tuple] = None,  # grey scale or (red, green, blue),
        fill_color: Union[int, tuple] = None,  # grey scale or (red, green, blue),
        underline: bool = False,
        t_margin: Optional[int] = None,
        l_margin: Optional[int] = None,
        b_margin: Optional[int] = None,
    ):
        super().__init__(
            font_family,
            ((font_style or &#34;&#34;) + &#34;U&#34;) if underline else font_style,
            font_size_pt,
            color,
            fill_color,
        )
        self.t_margin = t_margin or 0
        self.l_margin = l_margin or 0
        self.b_margin = b_margin or 0

    def __repr__(self):
        return (
            super().__repr__()[:-1]
            + f&#34;, t_margin={self.t_margin}, l_margin={self.l_margin}, b_margin={self.b_margin})&#34;
        )

    def replace(
        self,
        /,
        font_family=None,
        emphasis=None,
        font_size_pt=None,
        color=None,
        fill_color=None,
        t_margin=None,
        l_margin=None,
        b_margin=None,
    ):
        return TextStyle(
            font_family=font_family or self.family,
            font_style=self.emphasis if emphasis is None else emphasis.style,
            font_size_pt=font_size_pt or self.size_pt,
            color=color or self.color,
            fill_color=fill_color or self.fill_color,
            t_margin=self.t_margin if t_margin is None else t_margin,
            l_margin=self.l_margin if l_margin is None else l_margin,
            b_margin=self.b_margin if b_margin is None else b_margin,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li>fpdf.fonts.TitleStyle</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></b></code>:
<ul class="hlist">
<li><code><a title="fpdf.fonts.FontFace.combine" href="#fpdf.fonts.FontFace.combine">combine</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.replace" href="#fpdf.fonts.FontFace.replace">replace</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="fpdf" href="index.html">fpdf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="fpdf.fonts.CoreFont" href="#fpdf.fonts.CoreFont">CoreFont</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fonts.CoreFont.cw" href="#fpdf.fonts.CoreFont.cw">cw</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.emphasis" href="#fpdf.fonts.CoreFont.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.encode_text" href="#fpdf.fonts.CoreFont.encode_text">encode_text</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.fontkey" href="#fpdf.fonts.CoreFont.fontkey">fontkey</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.get_text_width" href="#fpdf.fonts.CoreFont.get_text_width">get_text_width</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.i" href="#fpdf.fonts.CoreFont.i">i</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.name" href="#fpdf.fonts.CoreFont.name">name</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.type" href="#fpdf.fonts.CoreFont.type">type</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.up" href="#fpdf.fonts.CoreFont.up">up</a></code></li>
<li><code><a title="fpdf.fonts.CoreFont.ut" href="#fpdf.fonts.CoreFont.ut">ut</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.FontFace" href="#fpdf.fonts.FontFace">FontFace</a></code></h4>
<ul class="two-column">
<li><code><a title="fpdf.fonts.FontFace.color" href="#fpdf.fonts.FontFace.color">color</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.combine" href="#fpdf.fonts.FontFace.combine">combine</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.emphasis" href="#fpdf.fonts.FontFace.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.family" href="#fpdf.fonts.FontFace.family">family</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.fill_color" href="#fpdf.fonts.FontFace.fill_color">fill_color</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.replace" href="#fpdf.fonts.FontFace.replace">replace</a></code></li>
<li><code><a title="fpdf.fonts.FontFace.size_pt" href="#fpdf.fonts.FontFace.size_pt">size_pt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.Glyph" href="#fpdf.fonts.Glyph">Glyph</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.Glyph.glyph_id" href="#fpdf.fonts.Glyph.glyph_id">glyph_id</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.glyph_name" href="#fpdf.fonts.Glyph.glyph_name">glyph_name</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.glyph_width" href="#fpdf.fonts.Glyph.glyph_width">glyph_width</a></code></li>
<li><code><a title="fpdf.fonts.Glyph.unicode" href="#fpdf.fonts.Glyph.unicode">unicode</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.HarfBuzzFont" href="#fpdf.fonts.HarfBuzzFont">HarfBuzzFont</a></code></h4>
</li>
<li>
<h4><code><a title="fpdf.fonts.PDFFontDescriptor" href="#fpdf.fonts.PDFFontDescriptor">PDFFontDescriptor</a></code></h4>
</li>
<li>
<h4><code><a title="fpdf.fonts.SubsetMap" href="#fpdf.fonts.SubsetMap">SubsetMap</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.SubsetMap.get_all_glyph_names" href="#fpdf.fonts.SubsetMap.get_all_glyph_names">get_all_glyph_names</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.get_glyph" href="#fpdf.fonts.SubsetMap.get_glyph">get_glyph</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.items" href="#fpdf.fonts.SubsetMap.items">items</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.pick" href="#fpdf.fonts.SubsetMap.pick">pick</a></code></li>
<li><code><a title="fpdf.fonts.SubsetMap.pick_glyph" href="#fpdf.fonts.SubsetMap.pick_glyph">pick_glyph</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.TTFFont" href="#fpdf.fonts.TTFFont">TTFFont</a></code></h4>
<ul class="">
<li><code><a title="fpdf.fonts.TTFFont.close" href="#fpdf.fonts.TTFFont.close">close</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cmap" href="#fpdf.fonts.TTFFont.cmap">cmap</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.cw" href="#fpdf.fonts.TTFFont.cw">cw</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.desc" href="#fpdf.fonts.TTFFont.desc">desc</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.emphasis" href="#fpdf.fonts.TTFFont.emphasis">emphasis</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.encode_text" href="#fpdf.fonts.TTFFont.encode_text">encode_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.fontkey" href="#fpdf.fonts.TTFFont.fontkey">fontkey</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.get_text_width" href="#fpdf.fonts.TTFFont.get_text_width">get_text_width</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.glyph_ids" href="#fpdf.fonts.TTFFont.glyph_ids">glyph_ids</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.hbfont" href="#fpdf.fonts.TTFFont.hbfont">hbfont</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.i" href="#fpdf.fonts.TTFFont.i">i</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.missing_glyphs" href="#fpdf.fonts.TTFFont.missing_glyphs">missing_glyphs</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.name" href="#fpdf.fonts.TTFFont.name">name</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.perform_harfbuzz_shaping" href="#fpdf.fonts.TTFFont.perform_harfbuzz_shaping">perform_harfbuzz_shaping</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.scale" href="#fpdf.fonts.TTFFont.scale">scale</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.shape_text" href="#fpdf.fonts.TTFFont.shape_text">shape_text</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.shaped_text_width" href="#fpdf.fonts.TTFFont.shaped_text_width">shaped_text_width</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.subset" href="#fpdf.fonts.TTFFont.subset">subset</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ttffile" href="#fpdf.fonts.TTFFont.ttffile">ttffile</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ttfont" href="#fpdf.fonts.TTFFont.ttfont">ttfont</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.type" href="#fpdf.fonts.TTFFont.type">type</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.up" href="#fpdf.fonts.TTFFont.up">up</a></code></li>
<li><code><a title="fpdf.fonts.TTFFont.ut" href="#fpdf.fonts.TTFFont.ut">ut</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="fpdf.fonts.TextStyle" href="#fpdf.fonts.TextStyle">TextStyle</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
